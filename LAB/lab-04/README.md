# LAB 4 — Interruptions for Externals, Timer, and Watchdog

## 1. Objective
The objectives of this lab are:
1. Understand and configure **external interrupts** for real-time event handling.
2. Implement **timer-based interrupts** for periodic tasks.
3. Configure and use the **watchdog timer** for system reliability.
4. Demonstrate proper interrupt service routine (ISR) design for embedded systems.

---

## 2. Background
Interrupts allow a microcontroller to **respond immediately** to events without constantly polling.  
In this lab, we will explore three main types:

- **External Interrupts**: Triggered by external hardware signals (e.g., button press, sensor output).
- **Timer Interrupts**: Generated by internal timers to run tasks at fixed intervals.
- **Watchdog Timer (WDT)**: Resets the MCU if the software hangs or fails to refresh the timer.

**Key Concepts:**
- **ISR (Interrupt Service Routine)** should be short and efficient.
- Avoid using `delay()` or blocking functions in ISRs.
- Use `volatile` variables for shared data between ISR and main code.

---

## 3. Hardware Requirements
- ESP32 development board
- Push button (for external interrupt)
- LED (status indicator)
- Breadboard and jumper wires

---

## 4. Software Requirements
- **Arduino IDE** with ESP32 board support installed
- ESP32 core libraries:
  - `WiFi.h` (optional for network-based testing)
  - `esp_task_wdt.h` (for watchdog configuration)

---

## 5. Lab Tasks & Implementation

### Task 1: External Interrupt
We will configure a push button to trigger an interrupt when pressed.

```cpp
#define BUTTON_PIN 15
volatile bool buttonPressed = false;

void IRAM_ATTR handleButtonInterrupt() {
  buttonPressed = true;  // Flag to handle in loop()
}

void setup() {
  Serial.begin(115200);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), handleButtonInterrupt, FALLING);
}

void loop() {
  if (buttonPressed) {
    Serial.println("Button Pressed!");
    buttonPressed = false;
  }
}
```

---

### Task 2: Timer Interrupt
ESP32 has multiple hardware timers. We’ll use one to toggle an LED every second.

```cpp
hw_timer_t * timer = NULL;
volatile bool ledState = false;

void IRAM_ATTR onTimer() {
  ledState = !ledState;
  digitalWrite(2, ledState);
}

void setup() {
  Serial.begin(115200);
  pinMode(2, OUTPUT);

  timer = timerBegin(0, 80, true);  // 80 prescaler -> 1 tick = 1µs
  timerAttachInterrupt(timer, &onTimer, true);
  timerAlarmWrite(timer, 1000000, true);  // 1 second
  timerAlarmEnable(timer);
}

void loop() {
  // Main loop does nothing; LED toggles in ISR
}
```

---

### Task 3: Watchdog Timer
We configure the WDT to reset the MCU if the loop hangs for more than 3 seconds.

```cpp
#include "esp_task_wdt.h"

#define WDT_TIMEOUT 3  // seconds

void setup() {
  Serial.begin(115200);
  esp_task_wdt_init(WDT_TIMEOUT, true); // Enable panic reset
  esp_task_wdt_add(NULL); // Add current thread to WDT
}

void loop() {
  Serial.println("Loop running...");
  delay(1000);
  esp_task_wdt_reset(); // Refresh WDT
}
```

**Test:** Comment out `esp_task_wdt_reset()` and observe the ESP32 auto-reset after 3 seconds.

---
### Task 4: Integrating WDT (Watchdog Timer) with LM73 temperature sensor polling
We configure the WDT to reset the MCU if the loop hangs for more than 10 seconds.

```cpp
#include <Wire.h>
#include "esp_task_wdt.h"

#define LM73_ADDR 0x4D // Default I2C address for LM73

void setup() {
  Serial.begin(115200);
  Wire.begin(4, 5); // SDA = 4, SCL = 5 

  // Initialize Watchdog Timer
  esp_task_wdt_init(10, true);     // 10 seconds timeout, panic=true
  esp_task_wdt_add(NULL);          // Add loop task to watchdog

  Serial.println("LM73 + WDT Example Started");
}

float readTemperatureLM73() {
  Wire.beginTransmission(LM73_ADDR);
  Wire.write(0x00); // Temperature register
  Wire.endTransmission(false); // Send repeated start
  Wire.requestFrom(LM73_ADDR, 2);

  if (Wire.available() == 2) {
    uint16_t raw = Wire.read() << 8 | Wire.read();
    float temp = (raw >>= 2) * 0.03125; // LM73 outputs 13-bit temp 
    return temp;
  }
  return NAN; // Not a Number if failed
}

void loop() {
  float temp = readTemperatureLM73();
  if (!isnan(temp)) {
    Serial.print("LM73 Temperature: ");
    Serial.print(temp);
    Serial.println(" °C");
  } else {
    Serial.println("Failed to read LM73");
  }

  // Feed the watchdog
  esp_task_wdt_reset();

  delay(1000); // Simulate polling delay
}

---



## 6. Sleep Mode Implementation
To improve power efficiency, the ESP32 can be placed into various sleep modes (light sleep or deep sleep) and woken up by external interrupts or timers.

### Example: Deep Sleep with External Wake-up
```cpp
#include <Arduino.h>

void setup() {
  Serial.begin(115200);
  delay(1000); // Allow serial monitor to start

  Serial.println("Going to deep sleep for 10 seconds...");
  esp_sleep_enable_timer_wakeup(10 * 1000000); // 10 seconds
  esp_deep_sleep_start();
}

void loop() {
  // Will not be called until device wakes up
}
```

**Wake Sources**:
- **Timer wake-up**: Automatically wakes after a set interval.
- **External GPIO wake-up**: Wake when a pin changes state.
- **Touch wake-up**: Trigger from capacitive touch pads.

### Notes
- Deep sleep drastically reduces current draw (tens of microamps).
- All volatile data is lost; store important data in RTC memory if needed.

## 6. Exercises
1. Modify the **external interrupt** to count button presses instead of just printing a message.
2. Use a **timer interrupt** to sample an analog sensor at 100 Hz.
3. Configure the **watchdog timer** to reset the ESP32 after 5 seconds of inactivity.
4. Combine external and timer interrupts in a single program.
5. Log system uptime to Serial each time the watchdog resets the board.

---

## 7. Conclusion
In this lab, you learned how to:
- Configure and use **external interrupts** for event-driven programming.
- Implement **timer-based interrupts** for periodic operations.
- Apply a **watchdog timer** to enhance system robustness.

Interrupt-driven programming increases efficiency by allowing the processor to remain idle until an event occurs, while watchdog timers safeguard against software hangs. These are critical skills for building reliable embedded systems.

